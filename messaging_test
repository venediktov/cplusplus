
#include <chrono>
#include <iterator>
#include <fstream>
#include <algorithm>
#include <random>
#include <memory>
#include <iostream>
#include <boost/program_options.hpp>
#include <boost/log/trivial.hpp>

#define LOG(x) BOOST_LOG_TRIVIAL(x) //TODO: move to core.hpp

extern void init_framework_logging(const std::string &) ;

namespace po = boost::program_options;

int main(int argc, char**argv) {

  init_framework_logging("/tmp/openrtb_cache_test_log");

  std::string local_address;
  std::string remote_address;
  std::string type;
  po::options_description desc;
        desc.add_options()
            ("help", "produce help message")
            ("local_address", po::value<std::string>(&local_address)->default_value("0.0.0.0"), "listen to this address")
            ("remote_address",po::value<std::string>(&remote_address), "respond to remote address")
            ("type", po::value<std::string>(&type)->default_value("broadcast"), "")
        ;

  boost::program_options::variables_map vm;
  try {
    po::store(po::parse_command_line(argc, argv, desc), vm);
    po::notify(vm);
  } catch ( const std::exception& ) {
    LOG(error) << desc;
    return 1;
  }

  if (vm.count("help")) {
      LOG(info) << desc;
      return 0;
  }

  std::vector<CityCountry> cities;
  if (vm.count("city_source")) {
     std::ifstream in {file_name};
     if ( !in ) {
        LOG(error) << "could not open file " << file_name << " exiting...";
        return 1;
     }
     std::copy ( std::istream_iterator<CityCountry>(in), std::istream_iterator<CityCountry>(), std::back_inserter(cities)) ;
     if (vm.count("populate")) {
         cache.clear();
         populate_cache<Keys>(cities,cache);
     }

  }

  for ( int i=0; i<iter_count; ++i) {
     auto pick = random_pick(cities);
     auto sp = std::make_shared<std::stringstream>() ;
     std::vector<std::shared_ptr<CityCountry>> retrieved_cached_cities;
     {
       perf_timer<std::stringstream> timer(sp) ;
       if ( !cache.retrieve<Tag>(retrieved_cached_cities, cache.create_ipc_key(cities[pick].city) , cache.create_ipc_key(cities[pick].country) ) ) 
       { 
          return 1; 
       }
     }
     std::for_each(std::begin(retrieved_cached_cities), std::end(retrieved_cached_cities), [](std::shared_ptr<CityCountry> &cp) {
       LOG(debug) << *cp; 
     });
     LOG(info) << sp->str() ;
  }
  
}


