// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates matchers It can be invoked by running
// go generate
package main

import (
	"log"
	"os"
	"strings"
	"text/template"
	"time"
    "os/user"
    "reflect"
    "fmt"
)

//TODO: use reflection to create a list of fields in the template
type  Domain struct {
    name string   `cpp:"std::string"  ipc:"char_string""`
    dom_id uint32 `cpp:"uint32_t" ipc:"uint32_t"`
}

type CacheStorage struct {
    FieldName    string
    FieldType    string
	FieldTypeIPC string
}

func main() {

	domain := Domain{"",0}
	//t := reflect.TypeOf(domain)
	v := reflect.ValueOf(domain)

	cachedValues := make([]CacheStorage, v.NumField())

	for i := 0; i < v.NumField(); i++ {
		field := v.Type().Field(i)
		cachedValues[i].FieldType = field.Tag.Get("cpp")
		cachedValues[i].FieldTypeIPC = field.Tag.Get("ipc")
		cachedValues[i].FieldName = field.Name
		fmt.Println(cachedValues[i].FieldType)
		fmt.Println(cachedValues[i].FieldTypeIPC)
		fmt.Println(cachedValues[i].FieldName)
	}

	const generatedMatcherName  = "referer"


	usr, err := user.Current()
	die(err)

	f, err := os.Create(strings.Join([]string{usr.HomeDir, "\\" , generatedMatcherName, ".hpp"}, ""))
	die(err)
	defer f.Close()

	matcherTemplate.Execute(f, struct {
		Timestamp   time.Time
		Matchername string
		CachedValues []CacheStorage
	}{
		Timestamp:   time.Now(),
		Matchername: generatedMatcherName,
		CachedValues: cachedValues,
	})

}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

var funcMap = template.FuncMap{
"ToUpper": strings.ToUpper,
"ToLower": strings.ToLower,
"Title" : strings.Title,
}

var matcherTemplate = template.Must(template.New("").Funcs(funcMap).Parse(`// Matcher Code generated by go generate; DO NOT EDIT.
// This file was generated by robots at
// {{ .Timestamp }}
/*
 * File:   {{.Matchername | ToLower}}.hpp
 *
 */

{{$entities := .CachedValues}}

#pragma once
#ifndef {{.Matchername|ToUpper}}_HPP
#define {{.Matchername|ToUpper}}_HPP

#include <string>
#include <cstdint>
#include <iostream>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/case_conv.hpp>
#include <boost/interprocess/containers/string.hpp>
#include <boost/multi_index_container.hpp>
#include <boost/multi_index/ordered_index.hpp>
#include <boost/multi_index/member.hpp>
#include <boost/multi_index/composite_key.hpp>
#include "rtb/datacache/any_str_ops.hpp"
//#include "rtb/common/uri_grammar.hpp"
#include "core/tagged_tuple.hpp"
//#include "../bidder_experimental/config.hpp"

struct {{.Matchername|Title}} {
    {{range $entity := $entities}}
    {{$entity.FieldType}} {{$entity.FieldName}}
    {{end}}

    {{.Matchername|Title}}( {{range $i,$entity := $entities}} {{$entity.FieldType}} &&{{$entity.FieldName}}{{if $i}},{{end}}{{end}}) : {{range $i,$entity := $entities}}{{$entity.FieldName}}{ {{$entity.FieldName}} }{{if $i}},{{end}}{{end}}
    {}

    {{.Matchername|Title}}(): {{range $i,$entity := $entities}}{{$entity.FieldName}}{}{{if $i}},{{end}}{{end}}
    {}

    friend std::ostream &operator<<(std::ostream & os, const std::shared_ptr<{{.Matchername|Title}}> &dom) {
        os << *dom;
        return os;
    }
    friend std::ostream &operator<<(std::ostream & os, const {{.Matchername|Title}} &value)  {
        os << value.key << "|"
           << value.other
        ;
        return os;
    }
    friend std::istream &operator>>(std::istream &is, {{.Matchername|Title}} &value) {
        std::string record;
        if ( !std::getline(is, record) ){
            return is;
        }
        std::vector<std::string> fields;
        boost::split(fields, record, boost::is_any_of("\t"), boost::token_compress_on);
        if(fields.size() < 2) {
            return is;
        }
        value.other = atol(fields.at(0).c_str());
        value.key = fields.at(1);
        return is;
    }
};


namespace ipc { namespace data {


    template <typename Alloc>
    struct {{.Matchername|ToLower}}_entity {
        using char_string =  boost::interprocess::basic_string<char, std::char_traits<char>, Alloc>;

        //for tagging in multi_index_container
        struct tag {}; // search on key

        {{.Matchername}}_entity( const Alloc & a ) : alloc{a}, key{a}, other{}
        {}

        Alloc alloc;
        char_string key;
        uint32_t other;


        template<typename Key, typename Serializable>
        void store(Key && key, Serializable  &&data)  {
           auto value = key.template get<tag>();
           key = char_string(value.data(), value.size(), alloc);
           other = data.other;
        }

        template<typename Serializable>
        void retrieve(Serializable  & data) const {
           data.key = std::move(std::string(name.data(), name.length()));
           data.other = other;
        }
        //needed for ability to update after matching by calling index.modify(itr,entry)
        void operator()({{.Matchername|ToLower}}_entity &entry) const {
            entry.key=key;
            entry.other=other;
        }
    };

    template<typename Alloc>
    using {{.Matchername}}_container =
    boost::multi_index_container<
        {{.Matchername}}_entity<Alloc>,
        boost::multi_index::indexed_by<
            boost::multi_index::ordered_unique<
                  boost::multi_index::tag<typename {{.Matchername}}_entity<Alloc>::name_tag>,
                  boost::multi_index::composite_key<
                      {{.Matchername}}_entity<Alloc>,
                      BOOST_MULTI_INDEX_MEMBER({{.Matchername|ToLower}}_entity<Alloc>,typename {{.Matchername|ToLower}}_entity<Alloc>::char_string,name),
                      BOOST_MULTI_INDEX_MEMBER({{.Matchername|ToLower}}_entity<Alloc>,uint32_t,dom_id)
                  >,
                  boost::multi_index::composite_key_compare<
                      ufw::any_str_less<Alloc> , std::less<uint32_t>
                  >
            >
        >,
        boost::interprocess::allocator<{{.Matchername|Title}},typename Alloc::segment_manager>
    > ;
}}

template <typename Config,
          typename Memory = typename mpclmi::ipc::Shared,
          typename Alloc = typename datacache::entity_cache<Memory, ipc::data::{{.Matchername|ToLower}}_container>::char_allocator >
class {{.Matchername|Title}}Entity {
        using Cache = datacache::entity_cache<Memory, ipc::data::{{.Matchername|ToLower}}_container> ;
        using NameTag = typename ipc::data::{{.Matchername|ToLower}}_entity<Alloc>::name_tag;
        using Keys = vanilla::tagged_tuple<NameTag, std::string>;
    public:
        {{.Matchername|Title}}Entity(const Config &config):
            config{config}, cache(config.data().{{.Matchername}}_ipc_name)
        {}
        void load() noexcept(false) {
            std::ifstream in{config.data().{{.Matchername|ToLower}}_source};
            if (!in) {
                throw std::runtime_error(std::string("could not open file ") + config.data().{{.Matchername|ToLower}}_source + " exiting...");
            }
            LOG(debug) << "File opened " << config.data().{{.Matchername|ToLower}}_source;
            cache.clear();

            std::for_each(std::istream_iterator<{{.Matchername|Title}}>(in), std::istream_iterator<{{.Matchername|Title}}>(), [&](const {{.Matchername|Title}} &value){
                using namespace boost::algorithm;
                if(!cache.insert(Keys{to_lower_copy(value.key)}, value).second) {
                    LOG(debug) << "Adding " << value << " failed!";
                }
                else {
                    LOG(debug) << "Adding " << value << " done!";
                }

            });
        }

        template<typename ...Args>
        bool retrieve({{.Matchername|Title}} &value, Args args...) {
            return cache.template retrieve<NameTag>(value, args)...;
        }

    private:
        const Config &config;
        Cache cache;

};

#endif /* {{.Matchername|ToUpper}}_HPP */
`))

